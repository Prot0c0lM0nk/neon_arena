<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Arena FPS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
        }
        
        #startScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .title {
            font-size: 4rem;
            margin-bottom: 0rem;
            color: #00ffea;
            text-shadow: 0 0 10px #00ffea, 0 0 20px #00ffea;
        }
        
        .weapon-selection {
            display: flex;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .weapon-card {
            width: 200px;
            height: 300px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffea;
            border-radius: 10px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .weapon-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 0 20px #00ffea;
        }
        
        .weapon-card h3 {
            color: #00ffea;
            margin: 1rem 0;
        }
        
        .weapon-stats {
            width: 100%;
            margin-top: 1rem;
        }
        
        .stat-bar {
            display: inline-block; /* Add this! It makes the span act like a box */
            width: 100px;         /* Give the container a fixed width */
            height: 10px;
            background: #333;
            margin: 0.5rem 0;
            position: relative;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .stat-fill {
            display: block;
            height: 100%;
            background: #00ffea;
            position: absolute;
            left: 0;
            top: 0;
        }
        
        #startButton {
            margin-bottom: 4rem;
            padding: 1rem 1rem;
            font-size: 1.2rem;
            background: #00ffea;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #startButton:hover {
            background: #00b3a1;
            transform: scale(1.1);
        }
        
        #gameContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-size: 1.2rem;
            text-shadow: 0 0 5px #000;
        }
        
        #ammo, #health, #round {
            margin: 5px 0;
        }
        
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffea;
        }
        
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            display: none;
            z-index: 200;
        }
        
        #blackScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 300;
            display: none;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1 class="title">NEON ARENA</h1>
        <h2>SELECT YOUR WEAPON</h2>
        <div class="weapon-selection">
            <div class="weapon-card" data-weapon="rifle">
                <h3>Rapid-Fire Rifle</h3>
                <div class="weapon-stats">
                    <div>Damage: <span class="stat-bar"><span class="stat-fill" style="width: 60%;"></span></span></div>
                    <div>Fire Rate: <span class="stat-bar"><span class="stat-fill" style="width: 90%;"></span></span></div>
                    <div>Range: <span class="stat-bar"><span class="stat-fill" style="width: 80%;"></span></span></div>
                    <div>Ammo: 30</div>
                </div>
            </div>
            <div class="weapon-card" data-weapon="shotgun">
                <h3>Heavy Shotgun</h3>
                <div class="weapon-stats">
                    <div>Damage: <span class="stat-bar"><span class="stat-fill" style="width: 90%;"></span></span></div>
                    <div>Fire Rate: <span class="stat-bar"><span class="stat-fill" style="width: 30%;"></span></span></div>
                    <div>Range: <span class="stat-bar"><span class="stat-fill" style="width: 40%;"></span></span></div>
                    <div>Ammo: 8</div>
                </div>
            </div>
            <div class="weapon-card" data-weapon="sniper">
                <h3>Precision Sniper</h3>
                <div class="weapon-stats">
                    <div>Damage: <span class="stat-bar"><span class="stat-fill" style="width: 100%;"></span></span></div>
                    <div>Fire Rate: <span class="stat-bar"><span class="stat-fill" style="width: 20%;"></span></span></div>
                    <div>Range: <span class="stat-bar"><span class="stat-fill" style="width: 100%;"></span></span></div>
                    <div>Ammo: 5</div>
                </div>
            </div>
        </div>
        <button id="startButton">START GAME</button>
    </div>
    
    <div id="gameContainer"></div>
    
    <div id="hud">
        <div id="ammo">AMMO: 0/0</div>
        <div id="health">HEALTH: 100</div>
        <div id="round">ROUND: 1</div>
    </div>
    
    <div id="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>
    
    <div id="gameOver">GAME OVER</div>
    <div id="blackScreen"></div>

    <script>
        // ================================================
        // GAME CONSTANTS AND CONFIGURATION
        // ================================================
        
        /**
         * Enemy configuration constants
         * These values define enemy behavior and appearance
         */
        const ENEMY_COLORS = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff]; // Color palette for enemy variety
        const ENEMY_SPEED = 0.02;          // Movement speed per frame
        const ENEMY_DAMAGE = 5;            // Damage per enemy bullet
        const ENEMY_FIRE_RATE = 1000;      // Time between shots in milliseconds
        const ENEMY_RANGE = 15;            // Distance at which enemies start shooting
        
        // ================================================
        // GAME STATE VARIABLES
        // ================================================
        
        /**
         * Three.js core objects - manage the 3D scene, rendering, and user interaction
         */
        let scene, camera, renderer, controls, clock;
        
        /**
         * Input and collision detection systems
         */
        let raycaster, mouse;
        
        /**
         * Game entities - player, enemies, and projectiles
         */
        let player, enemies = [], bullets = [], enemyBullets = [];
        
        /**
         * Player state and weapon management
         */
        let weaponType = 'rifle';           // Current selected weapon
        let ammo = 0;                       // Current ammo count
        let maxAmmo = 0;                    // Maximum ammo capacity
        let health = 100;                   // Player health
        
        /**
         * Game progression and timing
         */
        let round = 1;                      // Current round number
        let enemiesInRound = 5;             // Number of enemies this round
        let gameStarted = false;            // Game active state
        let lastFireTime = 0;               // Timestamp of last player shot
        let lastEnemyFireTime = 0;          // Timestamp of last enemy shot
        
        /**
         * Player physics and movement
         */
        let playerHeight = 1.6;             // Player camera height (meters)
        let playerSpeed = 0.2;              // Movement speed per frame
        let playerDirection = new THREE.Vector3(); // Current movement direction
        let moveForward = false;            // Keyboard input flags
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;                // Jump state
        let velocity = new THREE.Vector3(); // Physics velocity vector
        
        /**
         * World configuration
         */
        let worldWidth = 50;                // Arena width in meters
        let worldDepth = 50;                // Arena depth in meters
        let obstacles = [];                 // Array of wall objects for collision

        /**
         * Weapon configuration constants
         * Defines the three selectable weapon types with their unique characteristics.
         * 
         * INVARIANT: All weapons must have consistent property set for UI rendering
         * INVARIANT: Fire rate is in milliseconds between shots (lower = faster)
         * INVARIANT: Spread is in radians - affects bullet trajectory randomization
         * INVARIANT: Tracer properties control visual bullet representation
         * 
         * DEPENDENCIES: Used by fireWeapon(), createBullet(), reloadWeapon()
         * DEPENDENCIES: Referenced by startGame() for initial ammo setup
         * DEPENDENCIES: Referenced by HUD update for ammo display
         */
        const weapons = {
            rifle: {
                damage: 20,           // Moderate damage per shot
                fireRate: 150,        // 150ms between shots (~6.6 shots/sec)
                range: 100,           // Effective range in meters
                maxAmmo: 30,          // Magazine capacity
                ammo: 30,             // Current ammo (starts full)
                spread: 0.05,         // Slight accuracy variance
                color: 0x00ff00,      // Green tracer
                tracerWidth: 0.05,    // Visual tracer thickness
                tracerLength: 1.0     // Visual tracer length
            },
            shotgun: {
                damage: 10,           // Low per-pellet damage
                fireRate: 800,        // 800ms between shots (slow)
                range: 30,            // Short effective range
                maxAmmo: 8,           // Shell capacity
                ammo: 8,              // Current ammo
                spread: 0.2,          // Wide pellet spread
                pellets: 8,           // Number of pellets per shot
                color: 0xff0000,      // Red tracer
                tracerWidth: 0.1,     // Thicker tracers for visibility
                tracerLength: 0.5     // Shorter tracers
            },
            sniper: {
                damage: 80,           // High damage per shot
                fireRate: 1200,       // 1200ms between shots (very slow)
                range: 200,           // Long effective range
                maxAmmo: 5,           // Small magazine
                ammo: 5,              // Current ammo
                spread: 0.01,         // Very accurate
                color: 0x0000ff,      // Blue tracer
                tracerWidth: 0.03,    // Thin tracer
                tracerLength: 2.0     // Long tracer for visibility
            }
        };
        
        /**
         * Game initialization entry point.
         * Orchestrates the three-phase startup: event listeners, scene setup, animation loop.
         * 
         * INTENT: Single entry point for all game initialization
         * INTENT: Separation of concerns - input, rendering, and loop are distinct phases
         * 
         * INVARIANT: Must be called after DOM is fully loaded
         * INVARIANT: Three.js library must be loaded before this executes
         * 
         * DEPENDENCIES: Calls setupEventListeners(), setupScene(), animate()
         * DEPENDENCIES: Relies on global Three.js objects (THREE, PointerLockControls)
         * 
         * NOTE: This is called at the bottom of the script to start the game
         */
        function init() {
            // Set up event listeners
            setupEventListeners();
            
            // Set up the scene
            setupScene();
            
            // Start the animation loop
            animate();
        }
        
        /**
         * Sets up all event listeners for user input.
         * Handles weapon selection, game start, mouse input, and keyboard controls.
         * 
         * INTENT: Centralize all input event registration for easier management
         * INTENT: Weapon selection is visual feedback only until startGame() is called
         * 
         * INVARIANT: Event listeners must be attached before game starts
         * INVARIANT: Pointer lock controls are NOT initialized here - that's in setupScene()
         * 
         * DEPENDENCIES: Requires DOM elements: .weapon-card, #startButton
         * DEPENDENCIES: Calls startGame() on button click
         * DEPENDENCIES: Delegates to onMouseMove, onMouseClick, onKeyDown, onKeyUp
         * 
         * NOTE: Mouse movement listener may be redundant since PointerLockControls
         *       handles camera rotation internally. Kept for potential future use.
         */
        function setupEventListeners() {
            // Weapon selection - visual feedback and state update
            console.log('Setting up EventListeners');
            document.querySelectorAll('.weapon-card').forEach(card => {
                card.addEventListener('click', () => {
                    // Reset all cards to default border
                    document.querySelectorAll('.weapon-card').forEach(c => c.style.borderColor = '#00ffea');
                    // Highlight selected card
                    card.style.borderColor = '#ff00ff';
                    // Update global weapon selection state
                    weaponType = card.dataset.weapon;
                });
            });
            
            // Start button - initiates game session
            document.getElementById('startButton').addEventListener('click', startGame);
            
            // Mouse movement - tracks cursor for potential UI interactions
            // Note: Camera rotation is handled by PointerLockControls, not this
            document.addEventListener('mousemove', onMouseMove, false);
            
            // Mouse click - triggers weapon firing during gameplay
            document.addEventListener('click', onMouseClick, false);
            
            // Keyboard controls - movement and actions
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }
        
        /**
         * Initializes the Three.js scene, camera, renderer, and core systems.
         * This is the rendering foundation - must complete successfully before game can run.
         * 
         * INTENT: Create all Three.js objects needed for 3D rendering
         * INTENT: Separate scene initialization from game logic initialization
         * 
         * INVARIANT: scene, camera, renderer must be created before other objects
         * INVARIANT: PointerLockControls requires camera and document.body
         * INVARIANT: Clock must be created before animate() uses it
         * INVARIANT: Raycaster must exist before any collision detection
         * 
         * DEPENDENCIES: Calls createPlayer(), createEnvironment()
         * DEPENDENCIES: Attaches resize listener calling onWindowResize()
         * DEPENDENCIES: Appends renderer canvas to #gameContainer DOM element
         * 
         * THREE.JS OBJECTS CREATED:
         *   - Scene with dark blue background and fog for depth
         *   - PerspectiveCamera at player height
         *   - WebGLRenderer with antialiasing and shadows
         *   - PointerLockControls for FPS-style mouse look
         *   - Clock for delta time calculation
         *   - Raycaster for collision and shooting detection
         * 
         * NOTE: Fog (1-100 range) helps hide the edge of the world and improves performance
         * NOTE: Camera FOV 75 is standard for FPS games
         */
        function setupScene() {
            // Create scene with dark blue background and atmospheric fog
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            scene.fog = new THREE.Fog(0x111122, 1, 100);
            
            // Create camera at player height
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerHeight;
            
            // Create renderer with antialiasing and shadow support
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Initialize PointerLockControls for FPS-style mouse look
            // This creates a "neck" object that the camera is attached to
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            // Create clock for delta time calculation in animation loop
            clock = new THREE.Clock();
            
            // Create raycaster for collision detection and shooting
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Create player entity
            createPlayer();
            
            // Create environment (floor, walls, lighting)
            createEnvironment();
            
            // Handle window resize events
            window.addEventListener('resize', onWindowResize, false);
        }
        
        /**
         * Creates the player entity as a container object for position tracking.
         * The actual visual representation is the camera itself.
         * 
         * INTENT: Separate player logical position from camera visual representation
         * INTENT: Provide a target for enemies to track and shoot at
         * 
         * INVARIANT: Player position must stay synchronized with camera position
         * INVARIANT: Player Y position is fixed at playerHeight when on ground
         * 
         * DEPENDENCIES: Called by setupScene()
         * DEPENDENCIES: Position is updated by updatePlayer() every frame
         * DEPENDENCIES: Referenced by enemies for targeting and collision detection
         * 
         * NOTE: This is an invisible Object3D - the camera is what the player sees through
         * NOTE: Player position is the source of truth; camera copies from it
         */
        function createPlayer() {
            // Player is represented by an invisible Object3D at camera height
            // This separates the logical player entity from the visual camera
            player = new THREE.Object3D();
            player.position.y = playerHeight;
            scene.add(player);
        }
        
        /**
         * Creates the game environment: floor, cover walls, and lighting.
         * This establishes the playable arena with tactical cover elements.
         * 
         * INTENT: Create a visually cohesive arena with tactical cover
         * INTENT: Ensure walls don't spawn too close to player spawn (0,0)
         * INTENT: Provide both ambient and directional lighting with shadows
         * 
         * INVARIANT: Floor must be at Y=0 (rotated -90 degrees on X)
         * INVARIANT: Walls must be at least 5 meters from center (player spawn)
         * INVARIANT: Exactly 10 walls are created for cover
         * INVARIANT: All walls are added to obstacles[] for collision detection
         * INVARIANT: Wall Y position is half its height (so it sits on floor)
         * 
         * DEPENDENCIES: Called by setupScene()
         * DEPENDENCIES: Uses worldWidth, worldDepth for spawn boundaries
         * DEPENDENCIES: Pushes wall meshes to global obstacles[] array
         * 
         * WALL GENERATION ALGORITHM:
         *   1. Random dimensions: width 2-7m, height 1-3m, depth 2-7m
         *   2. Random position within arena (with 5m margin from edges)
         *   3. Reject positions within 5m of center (player spawn protection)
         *   4. Add to scene and obstacles array
         * 
         * LIGHTING SETUP:
         *   - Ambient: 0x404040 (soft gray fill)
         *   - Directional: White, intensity 0.8, from (0, 20, 10) with shadows
         * 
         * NOTE: Wall spawn uses rejection sampling - may loop multiple times per wall
         * NOTE: Material roughness/metalness gives subtle industrial aesthetic
         */
        function createEnvironment() {
            // Create floor plane - rotated -90 degrees on X to be horizontal
            const floorGeometry = new THREE.PlaneGeometry(worldWidth, worldDepth);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333344,      // Dark blue-gray
                roughness: 0.8,       // Matte finish
                metalness: 0.2        // Slight metallic sheen
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;  // Rotate to horizontal
            floor.receiveShadow = true;        // Receive shadows from objects
            scene.add(floor);
            
            // Generate 10 random walls for tactical cover
            for (let i = 0; i < 10; i++) {
                // Random wall dimensions
                const wallWidth = Math.random() * 5 + 2;   // 2-7 meters
                const wallHeight = Math.random() * 2 + 1;  // 1-3 meters
                const wallDepth = Math.random() * 5 + 2;   // 2-7 meters
                
                const wallGeometry = new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth);
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444455,      // Slightly lighter than floor
                    roughness: 0.7,       // Slightly less rough
                    metalness: 0.3        // More metallic
                });
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);

                let wallX, wallZ;
                let tooClose = true;

                // Rejection sampling: keep trying until position is valid
                while (tooClose) {
                    // Random position within arena bounds (with 5m margin)
                    wallX = Math.random() * (worldWidth - 10) - (worldWidth/2 - 5);
                    wallZ = Math.random() * (worldDepth - 10) - (worldDepth/2 - 5);
                    
                    // Calculate distance from center (0,0) - player spawn point
                    const distanceFromCenter = Math.sqrt(wallX * wallX + wallZ * wallZ);
                    if (distanceFromCenter > 5) {  // 5 meters is safe distance
                        tooClose = false;
                    }
                }

                // Position wall so it sits on floor (Y at half height)
                wall.position.set(wallX, wallHeight/2, wallZ);
                wall.castShadow = true;      // Cast shadows on other objects
                wall.receiveShadow = true;   // Receive shadows
                scene.add(wall);
                
                // CRITICAL: Add to obstacles array for collision detection
                obstacles.push(wall);
            }
            
            // Ambient light - soft fill lighting from all directions
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            // Directional light - main light source with shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 20, 10);  // Above and slightly forward
            directionalLight.castShadow = true;         // Enable shadow casting
            scene.add(directionalLight);
        }
        
        /**
         * Spawns enemy entities for a new round.
         * Clears existing enemies and creates new ones with valid spawn positions.
         * 
         * INTENT: Provide fresh enemy set for each round
         * INTENT: Ensure enemies spawn in valid locations (not on player or in walls)
         * INTENT: Cycle through color palette for visual variety
         * 
         * INVARIANT: All existing enemies are removed before new ones are created
         * INVARIANT: Enemies spawn at least 10 meters from player
         * INVARIANT: Enemies spawn at least 3 meters from any wall/obstacle
         * INVARIANT: Enemy Y position is fixed at 1 (half their height)
         * INVARIANT: Enemy health is always initialized to 100
         * INVARIANT: Enemy lastShot is always initialized to 0
         * 
         * DEPENDENCIES: Called by startGame() and nextRound()
         * DEPENDENCIES: Uses ENEMY_COLORS for visual variety
         * DEPENDENCIES: Uses worldWidth, worldDepth for spawn boundaries
         * DEPENDENCIES: References player.position for distance check
         * DEPENDENCIES: References obstacles[] for collision check
         * DEPENDENCIES: Adds enemies to global enemies[] array
         * 
         * ENEMY MESH PROPERTIES:
         *   - Geometry: ConeGeometry(0.5 radius, 2 height, 8 segments)
         *   - Material: MeshStandardMaterial with color from ENEMY_COLORS
         *   - Position: Y=1 (sits on floor, cone height is 2)
         *   - Custom properties: health (number), lastShot (timestamp)
         * 
         * SPAWN VALIDATION RULES:
         *   1. Must be >10m from player (fair engagement distance)
         *   2. Must be >3m from any obstacle (not inside walls)
         *   3. Within arena bounds (worldWidth/Depth - 10 margin)
         * 
         * NOTE: Uses rejection sampling - may loop multiple times per enemy
         * NOTE: Enemy cone points up by default, lookAt() in updateEnemies() orients them
         */
        function createEnemies(count) {
            // Remove existing enemies from scene and clear array
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];
            
            // Create requested number of enemies
            for (let i = 0; i < count; i++) {
                // Cone geometry: radius 0.5, height 2, 8 radial segments
                const enemyGeometry = new THREE.ConeGeometry(0.5, 2, 8);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: ENEMY_COLORS[i % ENEMY_COLORS.length],  // Cycle through colors
                    roughness: 0.5,
                    metalness: 0.5
                });
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                
                // Find valid spawn position using rejection sampling
                let positionFound = false;
                while (!positionFound) {
                    // Random position within arena bounds (5m margin from edges)
                    const enemyX = Math.random() * (worldWidth - 10) - (worldWidth/2 - 5);
                    const enemyZ = Math.random() * (worldDepth - 10) - (worldDepth/2 - 5);
                    
                    enemy.position.set(enemyX, 1, enemyZ);  // Y=1 for cone geometry
                    
                    // Rule 1: Don't spawn too close to player (minimum 10m)
                    const distanceToPlayer = enemy.position.distanceTo(player.position);
                    if (distanceToPlayer < 10) {
                        continue;  // Try again
                    }

                    // Rule 2: Don't spawn inside or too close to walls
                    if (obstacles.some(obs => enemy.position.distanceTo(obs.position) < 3.0)) {
                        continue;  // Try again
                    }
                    
                    positionFound = true;  // Valid position found
                }
                
                // Initialize enemy state
                enemy.health = 100;        // Full health
                enemy.lastShot = 0;        // Timestamp of last shot (0 = never)
                enemy.castShadow = true;   // Cast shadows
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        /**
         * Transitions from start screen to active gameplay.
         * Initializes game state, spawns first round enemies, and enables controls.
         * 
         * INTENT: Single entry point for game session start
         * INTENT: Reset all game state to initial values
         * INTENT: Lock pointer for FPS-style camera control
         * 
         * INVARIANT: Must be called after weapon selection (weaponType is set)
         * INVARIANT: Start screen must be visible when called
         * INVARIANT: Player health always starts at 100
         * INVARIANT: Round always starts at 1
         * INVARIANT: First round always has 5 enemies
         * INVARIANT: gameStarted is set to true AFTER all initialization
         * 
         * DEPENDENCIES: Called by start button click (setupEventListeners)
         * DEPENDENCIES: Uses weaponType selected in UI
         * DEPENDENCIES: References weapons[] for ammo initialization
         * DEPENDENCIES: Calls createEnemies(), updateHUD()
         * DEPENDENCIES: Uses PointerLockControls for mouse capture
         * 
         * STATE INITIALIZED:
         *   - ammo, maxAmmo from selected weapon
         *   - health = 100
         *   - round = 1
         *   - enemiesInRound = 5
         *   - gameStarted = true
         * 
         * UI TRANSITIONS:
         *   - Hides #startScreen
         *   - Shows #gameContainer (canvas)
         * 
         * POINTER LOCK:
         *   - Requests browser pointer lock with vendor prefixes
         *   - Also calls controls.lock() for PointerLockControls
         * 
         * NOTE: Vendor prefixes (moz, webkit) for older browser compatibility
         * NOTE: Console log for debugging weapon selection
         */
        function startGame() {
            // Log selected weapon for debugging
            console.log('Starting game with weapon:', weaponType);
            
            // Hide start screen, show game canvas
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            
            // Initialize game state from selected weapon
            const weapon = weapons[weaponType];
            ammo = weapon.ammo;
            maxAmmo = weapon.maxAmmo;
            
            // Reset player and round state
            health = 100;
            round = 1;
            enemiesInRound = 5;
            
            // Spawn first round enemies
            createEnemies(enemiesInRound);
            
            // Update HUD with initial values
            updateHUD();
            
            // Enable pointer lock for FPS controls
            // Vendor prefixes for cross-browser compatibility
            const element = document.body;
            element.requestPointerLock = element.requestPointerLock || 
                                       element.mozRequestPointerLock || 
                                       element.webkitRequestPointerLock;
            element.requestPointerLock();
            controls.lock();

            // Mark game as active - enables update loops
            gameStarted = true;
        }
        
        /**
         * Handles player death and game session cleanup.
         * Transitions from gameplay back to start screen with visual effects.
         * 
         * INTENT: Provide clear feedback for game over condition
         * INTENT: Clean up game state and return to menu
         * INTENT: Create dramatic death sequence (game over text -> black screen -> menu)
         * 
         * INVARIANT: gameStarted is set to false immediately
         * INVARIANT: Pointer lock is released to allow menu interaction
         * INVARIANT: Camera is reset to default position/rotation
         * INVARIANT: Total transition time is 4 seconds (2s delay + 2s black screen)
         * 
         * DEPENDENCIES: Called when health <= 0 (in updateBullets)
         * DEPENDENCIES: Uses DOM elements: #gameOver, #blackScreen, #gameContainer, #startScreen
         * DEPENDENCIES: References camera, playerHeight for reset
         * 
         * DEATH SEQUENCE TIMELINE:
         *   T+0s:   gameStarted = false, show "GAME OVER" text
         *   T+0s:   Release pointer lock
         *   T+2s:   Show black screen (covers everything)
         *   T+4s:   Hide black screen, hide game over, hide canvas
         *   T+4s:   Show start screen, reset camera
         * 
         * UI STATE CHANGES:
         *   - Shows #gameOver (red text overlay)
         *   - Shows #blackScreen (full screen black)
         *   - Hides #gameContainer (canvas)
         *   - Shows #startScreen (flex layout)
         * 
         * CAMERA RESET:
         *   - Rotation: (0, 0, 0) - facing forward
         *   - Position Y: playerHeight (1.6m)
         * 
         * NOTE: Vendor prefixes for exitPointerLock (cross-browser compatibility)
         * NOTE: Nested setTimeout creates the two-phase transition
         */
        function gameOver() {
            // Immediately stop game updates
            gameStarted = false;
            
            // Show game over text
            document.getElementById('gameOver').style.display = 'block';
            
            // Release pointer lock to allow mouse interaction with menu
            document.exitPointerLock = document.exitPointerLock || 
                                     document.mozExitPointerLock || 
                                     document.webkitExitPointerLock;
            document.exitPointerLock();
            
            // Two-phase transition: game over text -> black screen -> menu
            setTimeout(() => {
                // Phase 1: Show black screen after 2 seconds
                document.getElementById('blackScreen').style.display = 'block';
                
                setTimeout(() => {
                    // Phase 2: After another 2 seconds, return to menu
                    document.getElementById('blackScreen').style.display = 'none';
                    document.getElementById('gameOver').style.display = 'none';
                    document.getElementById('gameContainer').style.display = 'none';
                    document.getElementById('startScreen').style.display = 'flex';
                    
                    // Reset camera to default state
                    camera.rotation.set(0, 0, 0);  // Facing forward
                    camera.position.y = playerHeight;
                }, 2000);
            }, 2000);
        }
        
        /**
         * Progresses to the next round with increased difficulty.
         * Increments round counter, calculates enemy count, and spawns new enemies.
         * 
         * INTENT: Provide progressive difficulty curve
         * INTENT: Scale enemy count with round number
         * 
         * INVARIANT: Round number always increments by 1
         * INVARIANT: Enemy count formula: 5 + floor(round * 1.5)
         * INVARIANT: HUD is updated after enemy creation
         * 
         * DEPENDENCIES: Called when all enemies defeated (in updateBullets)
         * DEPENDENCIES: Calls createEnemies() with calculated count
         * DEPENDENCIES: Calls updateHUD() to show new round number
         * 
         * DIFFICULTY PROGRESSION:
         *   Round 1: 5 + floor(1 * 1.5) = 6 enemies
         *   Round 2: 5 + floor(2 * 1.5) = 8 enemies
         *   Round 3: 5 + floor(3 * 1.5) = 9 enemies
         *   Round 5: 5 + floor(5 * 1.5) = 12 enemies
         *   Round 10: 5 + floor(10 * 1.5) = 20 enemies
         * 
         * NOTE: Linear scaling with 1.5 multiplier provides gradual difficulty increase
         * NOTE: Floor ensures integer enemy counts
         */
        function nextRound() {
            // Increment round counter
            round++;
            
            // Calculate enemy count: base 5 + 1.5 per round
            enemiesInRound = 5 + Math.floor(round * 1.5);
            
            // Spawn new wave of enemies
            createEnemies(enemiesInRound);
            
            // Update HUD to show new round
            updateHUD();
        }
        
        function fireWeapon() {
            const weapon = weapons[weaponType];
            const currentTime = Date.now();
            
            // Check if we can fire (ammo and fire rate)
            if (ammo <= 0 || currentTime - lastFireTime < weapon.fireRate) {
                return;
            }
            
            // Use ammo
            ammo--;
            lastFireTime = currentTime;
            updateHUD();
            
            // Create bullet direction based on camera direction
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            if (weaponType === 'shotgun') {
                // Shotgun fires multiple pellets
                for (let i = 0; i < weapon.pellets; i++) {
                    const pelletDirection = direction.clone();
                    pelletDirection.x += (Math.random() - 0.5) * weapon.spread;
                    pelletDirection.y += (Math.random() - 0.5) * weapon.spread;
                    pelletDirection.z += (Math.random() - 0.5) * weapon.spread;
                    pelletDirection.normalize();
                    
                    createBullet(pelletDirection, weapon);
                }
            } else {
                // Other weapons fire single shot
                direction.x += (Math.random() - 0.5) * weapon.spread;
                direction.y += (Math.random() - 0.5) * weapon.spread;
                direction.normalize();
                
                createBullet(direction, weapon);
            }
        }
        
        function createBullet(direction, weapon) {
            const origin = camera.position.clone();
            origin.y -= 0.5; // Adjust to gun height
            
            // Create tracer
            const tracerGeometry = new THREE.CylinderGeometry(
                weapon.tracerWidth, 
                weapon.tracerWidth, 
                weapon.tracerLength,
                8
            );
            const tracerMaterial = new THREE.MeshBasicMaterial({ 
                color: weapon.color,
                transparent: true,
                opacity: 0.8
            });
            const tracer = new THREE.Mesh(tracerGeometry, tracerMaterial);
            
            // Position and orient tracer
            tracer.position.copy(origin);
            tracer.lookAt(origin.clone().add(direction));
            tracer.rotateX(Math.PI / 2);
            scene.add(tracer);
            
            // Add bullet to array
            bullets.push({
                position: origin,
                direction: direction,
                speed: 1.0,
                range: weapon.range,
                damage: weapon.damage,
                mesh: tracer,
                distance: 0
            });
            
            // Play sound (placeholder)
            // In a real game, you would play a sound effect here
        }
        
        function enemyFire(enemy) {
            const currentTime = Date.now();
            
            // Check fire rate
            if (currentTime - enemy.lastShot < ENEMY_FIRE_RATE) {
                return;
            }
            
            enemy.lastShot = currentTime;
            
            // Calculate direction to player
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, enemy.position).normalize();
            
            // Add some inaccuracy
            direction.x += (Math.random() - 0.5) * 0.1;
            direction.z += (Math.random() - 0.5) * 0.1;
            direction.normalize();
            
            // Create enemy bullet
            const origin = enemy.position.clone();
            origin.y += 1; // Adjust height
            
            // Create tracer for enemy bullet
            const tracerGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
            const tracerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.8
            });
            const tracer = new THREE.Mesh(tracerGeometry, tracerMaterial);
            
            // Position and orient tracer
            tracer.position.copy(origin);
            tracer.lookAt(origin.clone().add(direction));
            tracer.rotateX(Math.PI / 2);
            scene.add(tracer);
            
            // Add enemy bullet to array
            enemyBullets.push({
                position: origin,
                direction: direction,
                speed: 0.8,
                range: ENEMY_RANGE,
                damage: ENEMY_DAMAGE,
                mesh: tracer,
                distance: 0
            });
        }
        
        function updateHUD() {
            document.getElementById('ammo').textContent = `AMMO: ${ammo}/${maxAmmo}`;
            document.getElementById('health').textContent = `HEALTH: ${Math.max(0, Math.floor(health))}`;
            document.getElementById('round').textContent = `ROUND: ${round}`;
        }
        
        function updateMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');
            const size = 200;
            const scale = size / Math.max(worldWidth, worldDepth);
            
            // Set canvas size
            canvas.width = size;
            canvas.height = size;
            
            // Clear canvas
            ctx.clearRect(0, 0, size, size);
            
            // Draw background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, size, size);
            
            // Draw player
            const playerX = (player.position.x + worldWidth/2) * scale;
            const playerY = (player.position.z + worldDepth/2) * scale;
            ctx.fillStyle = '#00ffea';
            ctx.beginPath();
            ctx.arc(playerX, playerY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw player direction
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            ctx.strokeStyle = '#00ffea';
            ctx.beginPath();
            ctx.moveTo(playerX, playerY);
            ctx.lineTo(
                playerX + direction.x * 10,
                playerY + direction.z * 10
            );
            ctx.stroke();
            
            // Draw enemies
            enemies.forEach(enemy => {
                const enemyX = (enemy.position.x + worldWidth/2) * scale;
                const enemyY = (enemy.position.z + worldDepth/2) * scale;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(enemyX, enemyY, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseMove(event) {
            if (!gameStarted) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onMouseClick(event) {
            if (!gameStarted) return;
            
            fireWeapon();
        }
        
        function onKeyDown(event) {
            if (!gameStarted) return;
            
            switch (event.keyCode) {
                case 87: // W
                    moveForward = true;
                    break;
                case 83: // S
                    moveBackward = true;
                    break;
                case 65: // A
                    moveLeft = true;
                    break;
                case 68: // D
                    moveRight = true;
                    break;
                case 32: // Space
                    if (canJump) {
                        velocity.y = 0.2;
                        canJump = false;
                    }
                    break;
                case 82: // R (reload)
                    reloadWeapon();
                    break;
            }
        }
        
        function onKeyUp(event) {
            if (!gameStarted) return;
            
            switch (event.keyCode) {
                case 87: // W
                    moveForward = false;
                    break;
                case 83: // S
                    moveBackward = false;
                    break;
                case 65: // A
                    moveLeft = false;
                    break;
                case 68: // D
                    moveRight = false;
                    break;
            }
        }
        
        function reloadWeapon() {
            if (ammo === weapons[weaponType].maxAmmo) return;
            
            // In a real game, you would play a reload sound and animation here
            ammo = weapons[weaponType].maxAmmo;
            updateHUD();
        }
        
        function updatePlayer(delta) {
            // Store old position for collision recovery
            const oldPos = player.position.clone();
            
            // Calculate movement direction based on keyboard input
            const moveVector = new THREE.Vector3();
            
            if (moveForward) moveVector.z -= playerSpeed;
            if (moveBackward) moveVector.z += playerSpeed;
            if (moveLeft) moveVector.x -= playerSpeed;
            if (moveRight) moveVector.x += playerSpeed;
            
            // Apply movement direction relative to camera orientation
            moveVector.applyQuaternion(camera.quaternion);
            moveVector.y = 0; // Keep movement horizontal
            
            // Apply movement to player
            player.position.add(moveVector);
            
            // Apply gravity
            velocity.y -= 0.01;
            player.position.y += velocity.y;
            
            // Check if player is on the ground
            if (player.position.y <= playerHeight) {
                player.position.y = playerHeight;
                velocity.y = 0;
                canJump = true;
            }
            
            // Check collision with obstacles using raycaster
            if (gameStarted) {
                const collisionDistance = 1.5; // Safe distance from obstacles
                
                // Check collision in all four directions
                const directions = [
                    new THREE.Vector3(1, 0, 0),  // Right
                    new THREE.Vector3(-1, 0, 0), // Left
                    new THREE.Vector3(0, 0, 1),  // Forward
                    new THREE.Vector3(0, 0, -1)  // Backward
                ];
                
                let collisionDetected = false;
                
                for (const dir of directions) {
                    raycaster.set(player.position, dir);
                    const intersects = raycaster.intersectObjects(obstacles);
                    
                    if (intersects.length > 0 && intersects[0].distance < collisionDistance) {
                        collisionDetected = true;
                        break;
                    }
                }
                
                // Also check if player is inside any obstacle (fallback check)
                if (!collisionDetected) {
                    for (const obstacle of obstacles) {
                        if (player.position.distanceTo(obstacle.position) < 2.0) {
                            collisionDetected = true;
                            break;
                        }
                    }
                }
                
                if (collisionDetected) {
                    player.position.copy(oldPos);
                }
            }
            
            // Keep player within world bounds
            player.position.x = Math.max(-worldWidth/2 + 1, Math.min(worldWidth/2 - 1, player.position.x));
            player.position.z = Math.max(-worldDepth/2 + 1, Math.min(worldDepth/2 - 1, player.position.z));
            
            // Update camera to follow player
            camera.position.copy(player.position);
        }
        
        function updateEnemies(delta) {
            enemies.forEach(enemy => {
                const oldPos = enemy.position.clone();
                
                // Move enemy toward player
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, enemy.position).normalize();

                // Keep distance from player
                const distance = enemy.position.distanceTo(player.position);
                if (distance > 5) {
                    enemy.position.x += direction.x * ENEMY_SPEED;
                    enemy.position.z += direction.z * ENEMY_SPEED;
                } else if (distance < 3) {
                    enemy.position.x -= direction.x * ENEMY_SPEED;
                    enemy.position.z -= direction.z * ENEMY_SPEED;
                }
                
                // Check collision with obstacles using raycaster (same as player logic)
                const collisionDistance = 1.5; // Safe distance from obstacles
                
                // Check collision in all four directions
                const directions = [
                    new THREE.Vector3(1, 0, 0),  // Right
                    new THREE.Vector3(-1, 0, 0), // Left
                    new THREE.Vector3(0, 0, 1),  // Forward
                    new THREE.Vector3(0, 0, -1)  // Backward
                ];
                
                let collisionDetected = false;
                
                for (const dir of directions) {
                    raycaster.set(enemy.position, dir);
                    const intersects = raycaster.intersectObjects(obstacles);
                    
                    if (intersects.length > 0 && intersects[0].distance < collisionDistance) {
                        collisionDetected = true;
                        break;
                    }
                }
                
                // Also check if enemy is inside any obstacle (fallback check)
                if (!collisionDetected) {
                    for (const obstacle of obstacles) {
                        if (enemy.position.distanceTo(obstacle.position) < 2.0) {
                            collisionDetected = true;
                            break;
                        }
                    }
                }
                
                if (collisionDetected) {
                    enemy.position.copy(oldPos);
                }
                
                // Keep enemy within world bounds
                enemy.position.x = Math.max(-worldWidth/2 + 1, Math.min(worldWidth/2 - 1, enemy.position.x));
                enemy.position.z = Math.max(-worldDepth/2 + 1, Math.min(worldDepth/2 - 1, enemy.position.z));
                
                // Face player
                enemy.lookAt(player.position);
                
                // Enemy shooting
                if (distance < ENEMY_RANGE) {
                    enemyFire(enemy);
                }
            });
        }
        
        function updateBullets(delta) {
            // Update player bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Store old position for collision detection
                const oldPos = bullet.position.clone();
                
                // Move bullet
                bullet.position.add(bullet.direction.clone().multiplyScalar(bullet.speed));
                bullet.distance += bullet.speed;
                
                // Update tracer position
                bullet.mesh.position.copy(bullet.position);
                
                // Check if bullet hit an enemy
                let hitEnemy = false;
                for (let j = 0; j < enemies.length; j++) {
                    const enemy = enemies[j];
                    if (bullet.position.distanceTo(enemy.position) < 1.0) {
                        // Hit enemy
                        enemy.health -= bullet.damage;
                        
                        // Check if enemy is dead
                        if (enemy.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                            
                            // Check if all enemies are dead
                            if (enemies.length === 0) {
                                nextRound();
                            }
                        }
                        
                        hitEnemy = true;
                        break;
                    }
                }
                
                // Check if bullet hit a wall using raycaster (more accurate)
                let hitWall = false;
                raycaster.set(oldPos, bullet.direction);
                const intersects = raycaster.intersectObjects(obstacles);
                
                if (intersects.length > 0) {
                    // Check if the intersection point is between old and new position
                    const intersectionPoint = intersects[0].point;
                    const distanceToIntersection = oldPos.distanceTo(intersectionPoint);
                    const distanceTraveled = bullet.speed;
                    
                    if (distanceToIntersection <= distanceTraveled) {
                        hitWall = true;
                    }
                }
                
                // Check if bullet is out of range or hit something
                if (bullet.distance > bullet.range || hitEnemy || hitWall) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
            
            // Update enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                // Store old position for collision detection
                const oldPos = bullet.position.clone();
                
                // Move bullet
                bullet.position.add(bullet.direction.clone().multiplyScalar(bullet.speed));
                bullet.distance += bullet.speed;
                
                // Update tracer position
                bullet.mesh.position.copy(bullet.position);
                
                // Check if bullet hit player
                if (bullet.position.distanceTo(player.position) < 1.0) {
                    health -= bullet.damage;
                    updateHUD();
                    
                    // Check if player is dead
                    if (health <= 0) {
                        gameOver();
                    }
                    
                    scene.remove(bullet.mesh);
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                // Check if bullet hit a wall using raycaster (more accurate)
                let hitWall = false;
                raycaster.set(oldPos, bullet.direction);
                const intersects = raycaster.intersectObjects(obstacles);
                
                if (intersects.length > 0) {
                    // Check if the intersection point is between old and new position
                    const intersectionPoint = intersects[0].point;
                    const distanceToIntersection = oldPos.distanceTo(intersectionPoint);
                    const distanceTraveled = bullet.speed;
                    
                    if (distanceToIntersection <= distanceTraveled) {
                        hitWall = true;
                    }
                }
                
                // Check if bullet is out of range or hit something
                if (bullet.distance > bullet.range || hitWall) {
                    scene.remove(bullet.mesh);
                    enemyBullets.splice(i, 1);
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (gameStarted) {
                // Update game state
                updatePlayer(delta);
                updateEnemies(delta);
                updateBullets(delta);
                updateMinimap();
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
